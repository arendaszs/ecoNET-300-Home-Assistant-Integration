---
description: Python 3.13 standards and Home Assistant integration development guidelines
globs: 
alwaysApply: true
---

# Python Standards for ecoNET-300

*Based on: https://developers.home-assistant.io/docs/development_guidelines*

## üö® MANDATORY: Code Style with Ruff

### **Code Formatting: Ruff (replaces `black`, `isort`, `flake8`)**

- **ALWAYS use Ruff** for code formatting and linting
- **NEVER use Black, isort, or flake8** - they are replaced by Ruff
- **Ruff configuration** is in `pyproject.toml`
- **Run Ruff** before committing: `ruff check .` and `ruff format .`

### **Ruff Commands:**

```bash
# Check code quality
ruff check .

# Format code
ruff format .

# Auto-fix issues
ruff check --fix .

# Check specific file
ruff check custom_components/econet300/
```

## PEP 8 & PEP 257 Compliance

Home Assistant enforces strict **PEP 8** (Python style) and **PEP 257** (Docstring Conventions) compliance.

### Summary of Most Relevant Points

- **Comments** should be full sentences and end with a period.
- **Imports** should be ordered: standard library ‚Üí third-party ‚Üí local; alphabetically within sections.
- **Constants** and the content of lists and dictionaries should be in alphabetical order.

## Core Standards

- Use Python 3.13 features and syntax (Home Assistant 2024.12+)
- Follow PEP 8 style guidelines
- Use type hints for all function parameters and return values
- Prefer f-strings over `%` or `str.format()` for string formatting
- Use async/await patterns for I/O operations
- Use dataclasses or attrs for data structures

## File Headers & Docstrings

### File Headers

The docstring in the file header should describe what the file is about.

```python
"""Support for ecoNET300 sensors."""
```

### Docstring Style

- Use **Google style** for docstrings when explaining parameters, return values, exceptions.
- Type annotations should already cover type info, so omit those from docstrings.

```python
def process_data(value: float, multiplier: int) -> float:
    """Process and scale the data value.

    Args:
        value: The raw value to process.
        multiplier: Scale factor to apply.

    Returns:
        The processed and scaled value.

    Raises:
        ValueError: If value is negative.
    """
```

## Logging Guidelines

### Log Message Format

- **Don't include** component or platform names; these are added automatically.
- Log messages do **NOT** end with a period.
- **Never log** sensitive data like API keys, passwords, or tokens.

```python
# CORRECT - no period at end, no component name
_LOGGER.error("No route to device: %s", self._resource)

# WRONG - has period, includes component name
_LOGGER.error("econet300: No route to device.")
```

### Log Levels

- `_LOGGER.debug` - Verbose details for debugging
- `_LOGGER.info` - Notable but non-problematic messages (use sparingly)
- `_LOGGER.warning` - Potential issues that don't prevent operation
- `_LOGGER.error` - Serious issues that affect functionality

### String Formatting in Logs

**ALWAYS use `%`-style formatting in logs** to avoid unnecessary string formatting when log level filters them out.

```python
# CORRECT - percentage formatting for logging
_LOGGER.info("Can't connect to the webservice %s at %s", string1, string2)
_LOGGER.debug("Processing entity %s with value %s", entity_id, value)

# WRONG - f-string in logging (formats even when suppressed)
_LOGGER.info(f"Can't connect to the webservice {string1} at {string2}")
```

## String Formatting in Code

**Prefer f-strings** in regular code (not logging).

```python
# CORRECT - f-string in regular code
message = f"{some_value} {some_other_value}"
entity_id = f"sensor.{device_name}_{sensor_type}"

# WRONG - old style formatting in code
message = "{} {}".format("New", "style")
message = "%s %s" % ("Old", "style")
```

## Typing & Type Hints

### Requirements

- Use **full type hints** throughout where possible.
- Static type checking is part of CI.
- For fully typed modules, enable strict checking via `.strict-typing` file.

```python
from typing import Any

def get_value(data: dict[str, Any], key: str) -> float | None:
    """Get a float value from data dictionary."""
    value = data.get(key)
    return float(value) if value is not None else None
```

### Common Type Patterns

```python
from collections.abc import Callable
from typing import Any

# Function types
async def async_setup_entry(
    hass: HomeAssistant,
    config_entry: ConfigEntry,
    async_add_entities: AddEntitiesCallback,
) -> None:
    """Set up the sensor platform."""

# Optional values
def process(value: str | None = None) -> str:
    """Process optional value."""

# Dictionary types
data: dict[str, Any] = {}

# List types
entities: list[Entity] = []
```

## Import Conventions

### Import Order

1. Standard library imports (alphabetically)
2. Blank line
3. Third-party imports (alphabetically)
4. Blank line
5. Local imports (alphabetically)

### Standard Home Assistant Aliases

```python
import homeassistant.helpers.config_validation as cv
import homeassistant.helpers.device_registry as dr
import homeassistant.helpers.entity_registry as er
import homeassistant.util.dt as dt_util
import voluptuous as vol
```

## Async Programming

### Requirements

- Use async/await for **all I/O operations**
- Avoid blocking operations in async functions
- Use `asyncio.timeout` instead of deprecated `async_timeout`
- Properly handle task cancellation

### Async Patterns

```python
import asyncio

# CORRECT - using asyncio.timeout
async def fetch_data(self) -> dict[str, Any]:
    """Fetch data with timeout."""
    async with asyncio.timeout(10):
        return await self._api.get_data()

# Entity property - NO I/O in getters
@property
def native_value(self) -> float | None:
    """Return the current value."""
    # Return cached value, don't fetch here
    return self._cached_value
```

## Entity Development Best Practices

### Entity Properties

- **Do NOT** perform I/O (network, disk) in property getters.
- Use `update()` or `async_update()` to fetch/calculate and cache values.
- Avoid calling `update()` in constructors.

```python
class EconetSensor(CoordinatorEntity, SensorEntity):
    """Sensor entity for ecoNET300."""

    @property
    def native_value(self) -> float | None:
        """Return the sensor value."""
        # Just return cached data, no I/O here
        return self.coordinator.data.get(self._key)

    async def async_update(self) -> None:
        """Update the entity."""
        # Fetch new data here if needed
        await self.coordinator.async_request_refresh()
```

### Entity Setup

- Group calls to `add_entities` when possible.
- Use `add_entities(..., update_before_add=True)` if initial update is needed.

```python
async def async_setup_entry(
    hass: HomeAssistant,
    config_entry: ConfigEntry,
    async_add_entities: AddEntitiesCallback,
) -> None:
    """Set up sensors from config entry."""
    coordinator = hass.data[DOMAIN][config_entry.entry_id]
    
    entities: list[EconetSensor] = []
    for key in SENSOR_KEYS:
        entities.append(EconetSensor(coordinator, key))
    
    # Add all entities at once
    async_add_entities(entities, update_before_add=True)
```

## Configuration Validation

- Use **voluptuous schemas** for configuration validation.
- Default parameters should be in the schema, not in `setup()`.
- Use existing constants from `homeassistant.const` where possible.

```python
import voluptuous as vol
from homeassistant.const import CONF_HOST, CONF_PORT
import homeassistant.helpers.config_validation as cv

CONFIG_SCHEMA = vol.Schema({
    vol.Required(CONF_HOST): cv.string,
    vol.Optional(CONF_PORT, default=80): cv.port,
})
```

## Error Handling

- Use proper exception handling with specific exception types.
- Log errors with appropriate log levels.
- Use `raise from` for exception chaining.
- Handle network timeouts and connection errors gracefully.

```python
try:
    data = await self._api.fetch_data()
except TimeoutError as err:
    _LOGGER.error("Timeout connecting to device: %s", err)
    raise UpdateFailed("Timeout connecting to device") from err
except ConnectionError as err:
    _LOGGER.warning("Connection failed: %s", err)
    raise ConfigEntryNotReady("Connection failed") from err
```

## Code Quality Tools

- **Ruff**: Primary linting and formatting tool (replaces black, isort, flake8)
- **MyPy**: Type checking
- **Codespell**: Spelling checks
- **Pytest**: Testing framework

## Avoid

- ‚ùå Blocking operations in async functions
- ‚ùå Hardcoded values (use constants)
- ‚ùå Duplicate code (extract common functionality)
- ‚ùå Overly complex functions (keep under 25 complexity)
- ‚ùå Unnecessary imports
- ‚ùå Debug print statements in production code
- ‚ùå I/O in property getters
- ‚ùå f-strings in logging (use `%`-style)
- ‚ùå Periods at end of log messages
- ‚ùå Logging sensitive information (API keys, tokens, passwords)
- ‚ùå Old-style string formatting (`%` or `.format()`) in regular code

## Pre-Commit Checklist

Before committing:

1. Run `ruff format .` to format code
2. Run `ruff check .` to check for issues
3. Run `ruff check --fix .` to auto-fix issues
4. Run `pytest` to verify tests pass
5. Verify no sensitive data in logs
6. Verify type hints are complete

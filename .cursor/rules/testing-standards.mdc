---
description: Testing standards with pytest and fixtures
globs: 
alwaysApply: true
---

# Testing Standards

## üß™ ALWAYS Check Existing Tests First

**BEFORE creating new test files, ALWAYS check if existing test files can be updated with new features.**

**Process:**

1. **Search existing tests** in the `tests/` directory
2. **Look for related test files** that might cover similar functionality
3. **Update existing tests** to include new features instead of creating duplicates
4. **Only create new test files** if no existing test covers the functionality

**Examples:**

- ‚úÖ **Good**: Update `test_icon_translations.py` to include select entity tests
- ‚ùå **Bad**: Create `test_select_icon_translations.py` when `test_icon_translations.py` exists
- ‚úÖ **Good**: Update `test_sensor_basic.py` to include new sensor types
- ‚ùå **Bad**: Create `test_new_sensor.py` when sensor tests already exist

**Benefits:**

- Reduces test file proliferation
- Maintains test organization
- Avoids duplicate test setup code
- Easier maintenance and discovery

## Test Framework

- Use pytest for testing framework
- Write unit tests for all public functions
- Mock external dependencies
- Test both success and error scenarios
- Use fixtures for common test data

## Test Structure

- Group tests by functionality
- Use descriptive test names
- Follow AAA pattern (Arrange, Act, Assert)
- Test edge cases and error conditions

## Mocking Guidelines

- Mock device API responses
- Use pytest-mock for mocking
- Create realistic test data
- Test different device types and models

## Coverage Requirements

- Aim for high test coverage
- Test all public interfaces
- Include integration tests for critical paths
- Test configuration flows

## Test Data

- Use fixtures for common test data
- Create realistic device responses
- Test with different parameter combinations
- Validate error handling scenarios

## Fixtures Folder Structure

**MANDATORY: Follow the established fixtures folder naming convention**

### üìÅ Controller Folder Naming

**Folder Structure:** `tests/fixtures/[CONTROLLER_NAME]/`

**Examples:**

- `tests/fixtures/ecoMAX360/`
- `tests/fixtures/ecoMAX810P-L/`
- `tests/fixtures/ecoSOL500/`
- `tests/fixtures/SControl MK1/`

### üìÑ JSON File Naming Convention

**Each controller folder MUST contain JSON files named after API endpoints:**

**Required Files:**

- `regParams.json` - Regular parameters endpoint response
- `sysParams.json` - System parameters endpoint response
- `editParams.json` - Edit parameters endpoint response (if applicable)
- `rmParamsData.json` - RM parameters data endpoint response
- `rmParamsDescs.json` - RM parameters descriptions endpoint response
- `rmParamsEnums.json` - RM parameters enums endpoint response
- `rmParamsNames.json` - RM parameters names endpoint response
- `rmStructure.json` - RM structure endpoint response
- `rmParamsComplete.json` - Complete RM parameters endpoint response

**File Content Requirements:**

- Each JSON file MUST contain the actual API response from the corresponding endpoint
- Responses should be realistic and representative of the controller's capabilities
- Include both success and error response examples when applicable
- Maintain consistent data structure across similar controllers

**Benefits:**

- Easy identification of controller-specific test data
- Clear mapping between endpoints and test fixtures
- Consistent test data organization
- Simplified test maintenance and updates
